# -*- encoding : utf-8 -*-

module RLetters
  module Documents
    module Serializers
      # Convert a document to a Ruby MARC record object
      class MARCRecord
        # Create a serializer
        #
        # @api public
        # @param document [Document] a document to serialize
        def initialize(document)
          unless document.is_a? Document
            fail ArgumentError, 'Cannot serialize a non-Document class'
          end
          @doc = document
        end

        # Return the user-friendly name of the serializer
        #
        # @return [String] name of the serializer
        def self.format
          'MARC::Record'
        end

        # Return a URL where information about this serializer can be found
        #
        # @return [String] URL for information about this format
        def self.url
          'https://github.com/ruby-marc/ruby-marc'
        end

        # Returns this document as a MARC::Record object
        #
        # Support for individual-article MARC records is spotty at best -- this
        # is a use case for which the MARC format was not intended.  To
        # generate these records, we primarily follow the advice as presented
        # in {PROPOSAL 2003-03}[http://www.loc.gov/marc/marbi/2003/2003-03.html],
        # "Definition of Data Elements for Article Level Descsription."  We
        # also adhere to the prior standard of providing a "free-form" citation
        # entry in field, 773, subfield $g (Host Item Entry, Related Parts).
        # This should ensure a reasonable degree of compatibility.
        #
        # In cases where significant parts of a document record are missing
        # (i.e., no author, no title, no year), it is possible that the MARC
        # generated by this method will be invalid.  We're currently not going
        # out of our way to patch up records for these edge cases.
        #
        # @api public
        # @return [MARC::Record] document as a MARC record
        # @example Write out this document as MARC-XML
        #   marc = RLetters::Documents::Serializers::MARCRecord.new(doc).serialize
        #   writer = MARC::XMLWriter.new('marc.xml')
        #   writer.write(marc)
        #   writer.close()
        def serialize
          record = ::MARC::Record.new

          record.append(::MARC::ControlField.new('001', @doc.uid))
          record.append(::MARC::ControlField.new('003', 'RLID'))
          record.append(::MARC::ControlField.new(
            '005', Time.now.strftime('%Y%m%d%H%M%S.0')
          ))

          if @doc.year.blank?
            year_control = '0000'
          else
            year_control = sprintf '%04d', @doc.year
          end
          record.append(::MARC::ControlField.new(
            '008', "110501s#{year_control}       ||||fo     ||0 0|eng d"
          ))

          record.append(::MARC::DataField.new('040', ' ', ' ',
                                              %w(a RLetters),
                                              %w(b eng),
                                              %w(c RLetters)))

          if @doc.doi.present?
            record.append(::MARC::DataField.new('024', '7', ' ',
                                                %w(2 doi),
                                                %W(a #{@doc.doi})))
          end

          if @doc.formatted_author_list.present?
            record.append(::MARC::DataField.new(
              '100', '1', ' ',
              ::MARC::Subfield.new(
                'a',
                author_to_marc(@doc.formatted_author_list[0])
              )
            ))

            @doc.formatted_author_list.each do |a|
              record.append(::MARC::DataField.new(
                '700', '1', ' ',
                ::MARC::Subfield.new('a', author_to_marc(a))
              ))
            end
          end

          if @doc.title.present?
            record.append(::MARC::DataField.new(
              '245', '1', '0',
              ['a', @doc.title + (@doc.title[-1] == '.' ? nil : '.')]
            ))
          end

          marc_volume = ''
          marc_volume << "v. #{@doc.volume}" if @doc.volume.present?
          marc_volume << ' ' if @doc.volume.present? && @doc.number.present?
          marc_volume << "no. #{@doc.number}" if @doc.number.present?
          record.append(::MARC::DataField.new(
            '490', '1', ' ',
            ::MARC::Subfield.new('a', @doc.journal),
            ::MARC::Subfield.new('v', marc_volume)
          ))
          record.append(::MARC::DataField.new(
            '830', ' ', '0',
            ::MARC::Subfield.new('a', @doc.journal),
            ::MARC::Subfield.new('v', marc_volume)
          ))

          marc_free = ''
          if @doc.volume.present?
            marc_free << "Vol. #{@doc.volume}"
            marc_free << (@doc.number.blank? ? ' ' : ', ')
          end
          marc_free << "no. #{@doc.number} " if @doc.number.present?
          marc_free << "(#{@doc.year})" if @doc.year.present?
          marc_free << ", p. #{@doc.pages}" if @doc.pages.present?

          marc_enumeration = ''
          marc_enumeration << @doc.volume if @doc.volume.present?
          marc_enumeration << ":#{@doc.number}" if @doc.number.present?
          marc_enumeration << "<#{@doc.start_page}" if @doc.start_page.present?

          record.append(::MARC::DataField.new(
            '773', '0', ' ',
            %W(t #{@doc.journal}),
            %W(g #{marc_free}),
            %W(q #{marc_enumeration}),
            %w(7 nnas)
          ))

          subfields = []
          subfields << ['a', @doc.volume] if @doc.volume.present?
          subfields << ['b', @doc.number] if @doc.number.present?
          subfields << ['c', @doc.start_page] if @doc.start_page.present?
          subfields << ['i', @doc.year] if @doc.year.present?
          record.append(::MARC::DataField.new('363', ' ', ' ', *subfields))

          if @doc.year.present?
            record.append(::MARC::DataField.new(
              '362', '0', ' ',
              %W(a #{@doc.year}.)
            ))
          end

          record
        end

        private

        # Convert the given author (from +formatted_author_list+) to MARC's format
        # @api private
        # @param [Hash] a author from +formatted_author_list+
        # @return [String] author formatted as MARC expects it
        def author_to_marc(a)
          author = ''
          author << a.von + ' ' if a.von.present?
          author << a.last
          author << ' ' + a.suffix if a.suffix.present?
          author << ', ' + a.first
          author
        end
      end
    end
  end
end
